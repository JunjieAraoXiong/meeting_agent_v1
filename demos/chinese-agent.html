<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é£ä¹¦ä¼šè®®åŠ©æ‰‹ - Meeting Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        .transcript-item { 
            transition: opacity 0.3s ease; 
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        }
        .revealed { opacity: 1; background: white; }
        .hidden { opacity: 0.4; background: #f9f9f9; }
        .highlight { 
            background: #fef3c7; 
            padding: 2px 4px; 
            border-radius: 4px; 
            cursor: pointer;
            font-weight: 500;
        }
        .highlight:hover { background: #fde047; }
        .chinese-text {
            line-height: 1.6;
            word-break: break-word;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">ğŸ¯ é£ä¹¦ä¼šè®®åŠ©æ‰‹ - Feishu Meeting Agent</h1>
        
        <!-- Controls -->
        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <div class="flex gap-2 mb-4">
                <button id="playBtn" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">â–¶ï¸ æ’­æ”¾</button>
                <button id="resetBtn" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">ğŸ”„ é‡ç½®</button>
                <button id="pasteBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">ğŸ“‹ ç²˜è´´è½¬å½•</button>
                <button id="loadFileBtn" class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">ğŸ“ åŠ è½½æ–‡ä»¶</button>
            </div>
            
            <!-- File selector -->
            <div id="fileSelector" class="mb-4 hidden">
                <select id="fileSelect" class="border rounded p-2 mr-2">
                    <option value="">é€‰æ‹©è½¬å½•æ–‡ä»¶...</option>
                    <option value="../transcriptions/20250630.txt">20250630.txt</option>
                    <option value="../transcriptions/20250703.txt">20250703.txt</option>
                </select>
                <button id="loadSelectedFile" class="px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600">åŠ è½½</button>
            </div>
            
            <!-- Timeline -->
            <div class="flex items-center gap-2 mb-2">
                <span id="currentTime" class="text-sm font-mono w-12">0:00</span>
                <input type="range" id="timeline" min="0" max="300" value="0" class="flex-1">
                <span id="maxTime" class="text-sm font-mono w-12">5:00</span>
            </div>
        </div>

        <!-- Main Content -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Left: Transcript -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-lg shadow p-4">
                    <h2 class="text-lg font-semibold mb-3">ğŸ“œ ä¼šè®®è½¬å½•</h2>
                    <div id="transcript" class="space-y-2 max-h-96 overflow-y-auto">
                        <!-- Transcript items will be inserted here -->
                    </div>
                </div>
            </div>
            
            <!-- Right: Terms -->
            <div class="lg:col-span-1">
                <div class="bg-white rounded-lg shadow p-4">
                    <h2 class="text-lg font-semibold mb-3">ğŸ“– å…³é”®æœ¯è¯­</h2>
                    <div id="activeTerm" class="text-blue-600 font-semibold mb-2">ç‚¹å‡»é«˜äº®æœ¯è¯­æŸ¥çœ‹å®šä¹‰</div>
                    <div id="termDefinition" class="text-gray-600 text-sm mb-4 chinese-text">æœ¯è¯­ä¼šéšç€ä¼šè®®è¿›åº¦é€æ¸æ˜¾ç¤ºã€‚</div>
                    <div id="termsList" class="flex flex-wrap gap-1">
                        <!-- Terms will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Paste Modal -->
    <div id="pasteModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 w-full max-w-2xl m-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">ğŸ“‹ ç²˜è´´è½¬å½•æ–‡æœ¬</h3>
                <button id="closeModal" class="text-gray-500 hover:text-gray-700">âœ•</button>
            </div>
            <textarea id="pasteArea" class="w-full h-64 border rounded p-3 font-mono text-sm chinese-text" 
                placeholder="åœ¨æ­¤ç²˜è´´é£ä¹¦è½¬å½•æ–‡æœ¬...

æ ¼å¼ç¤ºä¾‹:
æ±¤æ¬£é’° 00:00
ä¼šè®®å†…å®¹...

è¯´è¯äºº 1 01:30
æ›´å¤šå†…å®¹..."></textarea>
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelPaste" class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">å–æ¶ˆ</button>
                <button id="loadTranscript" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">åŠ è½½</button>
            </div>
        </div>
    </div>

    <script>
        // Sample data with proper Chinese encoding
        const SAMPLE_TRANSCRIPT = \`æ±¤æ¬£é’° 00:00
çŒ«æˆ´åœ¨èº«ä¸Šï¼Œç„¶ååˆæœ‰å®šä½ï¼Œåˆæœ‰ç³–åŒ…ä¸ç¿»è¯‘ã€‚å—¯ï¼Œå»å¹´å¥½åƒå°±æœ‰è¿™ä¸ªï¼Œå¥½åƒå°±æœ‰ä¸€ä¸ªï¼Œå»å¹´å¥½åƒæœ‰ä¸€ä¸ªç±»ä¼¼çš„ï¼Œå°±æ˜¯ä¹Ÿæˆ´åœ¨ä»€ä¹ˆèº«ä¸Šå•Šï¼Ÿç‹—å•Šï¼Ÿå¯¹å•Šï¼Œé‚£ä¸ªç½‘ç«™çš„å“ªé‡Œå•Šï¼Ÿé‚£ä¸ªæœ‰æ²¡æœ‰æ€»çš„é‚£ä¸ª listï¼Ÿå¦‚æœå•ç‹¬å‘ä¸€ä¸ªï¼ŒOKï¼Œæˆ‘æ¥å‘ä¸€ä¸ªè¿™ç§çš„ listï¼Œå…ˆï¼Œè¿™ä¸ªå…ˆåˆ°ï¼Œæˆ‘å‘ä¹Ÿè¡Œï¼Œå¼ è€å¸ˆä¸ç”¨å‘ã€‚

æ±¤æ¬£é’° 00:56
ç„¶åï¼Œå—¯ï¼Œè¦ä¸ç„¶æˆ‘ä»¬å…ˆè¯´ï¼Œå—¯ï¼Œå°±æ˜å¤©ï¼Œä¸æ˜¯è¿˜æ˜¯ä¸‹åˆæœ‰é‚£ä¸ªå‘¨ä¼šå˜›ï¼Ÿå—¯ï¼Œå¯¹ï¼Œå°±å¤§å®¶æœ€è¿‘æœ‰æ²¡æœ‰ä»€ä¹ˆå›°éš¾ï¼Ÿç„¶åä»¥åŠæœ‰æ²¡æœ‰è¯†åˆ«åˆ°ä»€ä¹ˆæœºä¼šã€æƒ³æ³•çš„ï¼Ÿç„¶åå…¶ä»–çš„å°±æ˜¯ä¾‹è¡Œçš„ï¼Œæ¯”å¦‚åœ¨ä¼šä¸Šå°±ä¾‹è¡ŒåŒæ­¥äº†ã€‚ä¸»è¦æ˜¯æˆ‘è§‰å¾—å¤§ä¼šå‰æ²¡æœ‰ä»€ä¹ˆè¦å†³ç­–çš„ã€‚å¯¹ï¼Œä¸€ä¸ªæ˜¯é‚£ä¸ªæˆ‘çŸ¥é“çš„ï¼Œä¸€ä¸ªæ˜¯å¿—æ—­é‚£è¾¹ï¼Œå¯¹å§ï¼Ÿä»–æ‰‹æœºæµ‹è¿™ä¸ªå¼€å‘çš„èµ„æºï¼Œæˆ–è€…è¯´è¿™ç§èƒ½åŠ›æˆ‘ä»¬è¿˜æ¯”è¾ƒçŸ­ç¼ºä¸€äº›ï¼Œæ˜¯å§ï¼Ÿè¡Œï¼Œè¿™ä¸ªæ˜¯å·²ç»çŸ¥é“äº†ã€‚

æ±¤æ¬£é’° 01:36
å¯¹ï¼Œæˆ‘çœ‹è¿™ä¸ªé»‘é©¬é¡¹ç›®ä»–ä»¬éƒ½æœ‰åœ¨å…¨æ· OA ä¸Šéƒ¨ç½²ä¸€äº› 1.5B çš„ç«¯è§‚æµ‹æ¨¡å‹ã€‚å—¯ï¼Œå®Œå…¨æ˜¯æ¯”æˆ‘ä»¬è¿™ä¸ªå‚æ•°é‡è¦å¤§å¾—å¤šï¼Œç„¶åå¥½åƒè¿˜è¡Œï¼Œé‚£å¯ä»¥è”ç³»ä¸‹ä»–ä»¬ï¼Œæ˜¯å§ï¼Ÿåæ­£å°±æ˜¯é‚£ä¸ªé»‘é©¬ï¼Œè¿™ä¸ªé©¬æ‹‰æ¾ä¸Šï¼Œå¯¹ï¼Œæˆ‘è§‰å¾—å¯èƒ½é‚£äº›äººä¹Ÿå¾ˆé‡è¦ï¼Œçœ‹å“ªäº›äººæœ‰æ„æ€ï¼Œç„¶åè·Ÿä»–ä»¬èŠä¸€èŠã€‚

æ±¤æ¬£é’° 02:04
ä½ è¿™ä¸ªçŸ¥é“ï¼Œç„¶åæˆ‘å†é—®ä¸€ä¸‹è¿™è¾¹çš„ Buzzï¼Œæ˜¯å§ï¼Ÿç„¶åæˆ‘ä¹Ÿç•™äº†ã€‚é‚£ä¸ªè¿˜æœ‰æ²¡æœ‰ä»€ä¹ˆå›°éš¾å•Šï¼Ÿæœ‰æ²¡æœ‰å¤§å®¶è§‰å¾—é‡åˆ°ä¸€äº›å›°éš¾çš„ï¼Ÿå¯¹ã€‚å—¯ï¼Œæœ‰ä¸ªæ¯”è¾ƒå¤§çš„å›°éš¾ï¼Œå°±è·Ÿä¸Šå¤´èŠçš„é‚£ä¸ªéšç§æ¨¡å¼ï¼Œå…¶å®æ„Ÿè§‰æ²¡æœ‰ç‰¹åˆ«å¥½çš„æ€è·¯ã€‚å—¯ï¼Œä½†æ˜¯æˆ‘åˆå›å½’åˆ°é‚£ä¸ªçœ¼é•œé—®é¢˜ï¼Œå› ä¸ºä¹‹å‰è°·æ­Œä»–ä»¬ä¸æ˜¯ä¹Ÿé‡åˆ°å¾ˆéš¾è§£é‡Šçš„é—®é¢˜å˜›ï¼Ÿå—¯ï¼Œç„¶åå›é¡¾äº†ä¸€ä¸‹é›·æœ‹çš„è§£æ³•ï¼Œé‚£ä¸ª Meta çš„è§£æ³•ï¼Œä½†æ˜¯åˆ°å’±ä»¬è¿™å—ï¼Œè¯­éŸ³ç›¸å…³çš„é‚£ä¸ªäººè¿˜æ²¡æœ‰ç‰¹åˆ«å¥½çš„ä¸€ä¸ªã€‚è¡Œï¼Œè¿™ä¸ªå¾…ä¼šæˆ‘ä»¬å†è¯´ã€‚è¡Œï¼Œè¿™ä¸ªåŒå­¦å¤§æ¦‚çŸ¥é“äº†ã€‚\`;

        // State
        let segments = [];
        let currentIndex = 0;
        let isPlaying = false;
        let interval;
        let terms = new Set();

        // Parse transcript
        function parseTranscript(text) {
            const lines = text.split('\\n').map(l => l.trim()).filter(l => l);
            const segs = [];
            const speakerPattern = /^(.+?)\\s+(\\d{1,2}:\\d{2})$/;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const match = line.match(speakerPattern);
                
                if (match) {
                    const speaker = match[1];
                    const time = match[2];
                    const timeSeconds = parseTime(time);
                    
                    // Collect content until next speaker
                    let content = '';
                    let j = i + 1;
                    while (j < lines.length && !lines[j].match(speakerPattern)) {
                        if (content) content += ' ';
                        content += lines[j];
                        j++;
                    }
                    
                    if (content) {
                        segs.push({
                            speaker,
                            time,
                            timeSeconds,
                            content,
                            index: segs.length
                        });
                    }
                    i = j - 1;
                }
            }
            return segs;
        }

        function parseTime(timeStr) {
            const [min, sec] = timeStr.split(':').map(Number);
            return min * 60 + sec;
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return \`\${min}:\${sec.toString().padStart(2, '0')}\`;
        }

        // Extract terms - improved Chinese detection
        function extractTerms(segments) {
            const termSet = new Set();
            segments.forEach(seg => {
                // Chinese compound terms
                const matches = seg.content.match(/([\u4e00-\u9fa5]{2,4})(é¡¹ç›®|æ¨¡å‹|æ¨¡å¼|ç³»ç»Ÿ|å¹³å°|ç®—æ³•|æ–¹æ¡ˆ|äº§å“|è®¾å¤‡|çœ¼é•œ|æ‰‹ç¯|å½•éŸ³)/g);
                if (matches) {
                    matches.forEach(term => termSet.add(term));
                }
                
                // Technical terms with numbers
                const techMatches = seg.content.match(/(\\d+\\.?\\d*[BM]?)\\s*(æ¨¡å‹|å‚æ•°|ç‰ˆæœ¬)/g);
                if (techMatches) {
                    techMatches.forEach(term => termSet.add(term));
                }
                
                // Brand names
                const brandMatches = seg.content.match(/\\b(Meta|Google|è°·æ­Œ|è‹¹æœ|å°ç±³|é›·æœ‹|Buzz|OA)\\b/gi);
                if (brandMatches) {
                    brandMatches.forEach(term => termSet.add(term));
                }
                
                // Common technical Chinese terms
                const commonTerms = seg.content.match(/(äººå·¥æ™ºèƒ½|æœºå™¨å­¦ä¹ |æ·±åº¦å­¦ä¹ |ç®—æ³•|å¤§æ¨¡å‹|ç«¯ä¾§|äº‘ç«¯|éšç§|å®‰å…¨|å½•éŸ³|è½¬å½•|è¯­éŸ³è¯†åˆ«|è‡ªç„¶è¯­è¨€)/g);
                if (commonTerms) {
                    commonTerms.forEach(term => termSet.add(term));
                }
            });
            return Array.from(termSet);
        }

        // Highlight terms in text
        function highlightTerms(text, termsList) {
            if (!termsList || termsList.length === 0) return escapeHtml(text);
            
            let result = text;
            // Sort by length (longest first) to avoid partial matches
            termsList.sort((a, b) => b.length - a.length);
            
            termsList.forEach(term => {
                const escapedTerm = term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');
                const regex = new RegExp(\`(\${escapedTerm})\`, 'gi');
                result = result.replace(regex, \`<span class="highlight" onclick="selectTerm('\$1')">\$1</span>\`);
            });
            return result;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Render transcript
        function renderTranscript() {
            const container = document.getElementById('transcript');
            container.innerHTML = '';
            
            segments.forEach((seg, index) => {
                const div = document.createElement('div');
                div.className = \`transcript-item p-3 border rounded \${index <= currentIndex ? 'revealed' : 'hidden'}\`;
                
                const highlightedContent = highlightTerms(seg.content, Array.from(terms));
                
                div.innerHTML = \`
                    <div class="text-xs text-gray-500 mb-1">
                        <span class="font-mono">\${seg.time}</span>
                        <span class="ml-2 px-2 py-1 bg-gray-100 rounded">\${seg.speaker}</span>
                    </div>
                    <div class="text-sm chinese-text">\${highlightedContent}</div>
                \`;
                container.appendChild(div);
            });
        }

        // Render terms
        function renderTerms() {
            const container = document.getElementById('termsList');
            container.innerHTML = '';
            
            Array.from(terms).forEach(term => {
                const button = document.createElement('button');
                button.className = 'text-xs px-2 py-1 bg-gray-100 rounded hover:bg-gray-200 chinese-text';
                button.textContent = term;
                button.onclick = () => selectTerm(term);
                container.appendChild(button);
            });
        }

        // Select term
        function selectTerm(term) {
            document.getElementById('activeTerm').textContent = term;
            document.getElementById('termDefinition').textContent = \`å®šä¹‰: \${term} - è¿™æ˜¯ä¼šè®®ä¸­æåˆ°çš„é‡è¦æœ¯è¯­ï¼Œå¯èƒ½æ¶‰åŠæŠ€æœ¯æ¦‚å¿µã€äº§å“åç§°æˆ–ä¸šåŠ¡æµç¨‹ã€‚\`;
        }

        // Load file from server
        async function loadFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(\`HTTP error! status: \${response.status}\`);
                }
                
                // Ensure we get text with proper encoding
                const text = await response.text();
                
                segments = parseTranscript(text);
                terms = new Set(extractTerms(segments));
                reset();
                renderTerms();
                console.log('Loaded file:', filename, 'segments:', segments.length);
                
                // Hide file selector
                document.getElementById('fileSelector').classList.add('hidden');
                
            } catch (error) {
                console.error('Error loading file:', error);
                alert(\`åŠ è½½æ–‡ä»¶å¤±è´¥: \${error.message}\`);
            }
        }

        // Play/pause
        function togglePlay() {
            const btn = document.getElementById('playBtn');
            if (isPlaying) {
                clearInterval(interval);
                btn.textContent = 'â–¶ï¸ æ’­æ”¾';
                btn.className = 'px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600';
            } else {
                interval = setInterval(() => {
                    if (currentIndex < segments.length - 1) {
                        currentIndex++;
                        renderTranscript();
                        updateTimeline();
                    } else {
                        togglePlay();
                    }
                }, 2000); // 2 seconds per segment
                btn.textContent = 'â¸ï¸ æš‚åœ';
                btn.className = 'px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600';
            }
            isPlaying = !isPlaying;
        }

        // Reset
        function reset() {
            if (isPlaying) togglePlay();
            currentIndex = -1;
            renderTranscript();
            updateTimeline();
        }

        // Update timeline
        function updateTimeline() {
            const timeline = document.getElementById('timeline');
            const currentTime = document.getElementById('currentTime');
            
            if (segments.length > 0) {
                const maxTime = segments[segments.length - 1].timeSeconds;
                timeline.max = maxTime;
                
                if (currentIndex >= 0 && currentIndex < segments.length) {
                    timeline.value = segments[currentIndex].timeSeconds;
                    currentTime.textContent = formatTime(segments[currentIndex].timeSeconds);
                } else {
                    timeline.value = 0;
                    currentTime.textContent = '0:00';
                }
                
                document.getElementById('maxTime').textContent = formatTime(maxTime);
            }
        }

        // Initialize
        function init() {
            console.log('åˆå§‹åŒ–ä¼šè®®åŠ©æ‰‹...');
            
            // Parse sample transcript
            segments = parseTranscript(SAMPLE_TRANSCRIPT);
            terms = new Set(extractTerms(segments));
            
            console.log('è§£æç‰‡æ®µ:', segments.length);
            console.log('æå–æœ¯è¯­:', Array.from(terms));
            
            // Render
            renderTranscript();
            renderTerms();
            updateTimeline();
            
            // Event listeners
            document.getElementById('playBtn').onclick = togglePlay;
            document.getElementById('resetBtn').onclick = reset;
            
            document.getElementById('pasteBtn').onclick = () => {
                document.getElementById('pasteModal').classList.remove('hidden');
                document.getElementById('pasteModal').classList.add('flex');
            };
            
            document.getElementById('loadFileBtn').onclick = () => {
                const selector = document.getElementById('fileSelector');
                selector.classList.toggle('hidden');
            };
            
            document.getElementById('loadSelectedFile').onclick = () => {
                const filename = document.getElementById('fileSelect').value;
                if (filename) {
                    loadFile(filename);
                }
            };
            
            document.getElementById('closeModal').onclick = 
            document.getElementById('cancelPaste').onclick = () => {
                document.getElementById('pasteModal').classList.add('hidden');
                document.getElementById('pasteModal').classList.remove('flex');
            };
            
            document.getElementById('loadTranscript').onclick = () => {
                const newText = document.getElementById('pasteArea').value;
                if (newText.trim()) {
                    segments = parseTranscript(newText);
                    terms = new Set(extractTerms(segments));
                    reset();
                    renderTerms();
                    console.log('åŠ è½½æ–°è½¬å½•:', segments.length, 'ä¸ªç‰‡æ®µ');
                }
                document.getElementById('pasteModal').classList.add('hidden');
                document.getElementById('pasteModal').classList.remove('flex');
            };
            
            document.getElementById('timeline').oninput = (e) => {
                const targetTime = parseInt(e.target.value);
                currentIndex = segments.findIndex(seg => seg.timeSeconds > targetTime) - 1;
                if (currentIndex < 0) currentIndex = segments.length - 1;
                renderTranscript();
                document.getElementById('currentTime').textContent = formatTime(targetTime);
            };
        }

        // Make selectTerm global for onclick
        window.selectTerm = selectTerm;

        // Start when page loads
        document.addEventListener('DOMContentLoaded', init);
        
        console.log('è„šæœ¬åŠ è½½æˆåŠŸ');
    </script>
</body>
</html>


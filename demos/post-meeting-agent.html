<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>é£ä¹¦ä¼šè®®åŠ©æ‰‹ - Post-Meeting Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Microsoft YaHei", sans-serif; 
        }
        .timeline-segment { 
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }
        .revealed { 
            opacity: 1; 
            background: white; 
            border-left-color: #3b82f6;
        }
        .hidden { 
            opacity: 0.3; 
            background: #f8fafc; 
        }
        .highlight { 
            background: #fef3c7; 
            padding: 2px 4px; 
            border-radius: 4px; 
            cursor: pointer; 
            font-weight: 500;
            transition: background 0.2s;
        }
        .highlight:hover { 
            background: #fde047; 
        }
        .llm-keyword {
            background: linear-gradient(135deg, #fef3c7 0%, #fde047 100%);
            border: 1px solid #f59e0b;
            box-shadow: 0 1px 2px rgba(245, 158, 11, 0.2);
        }
        .llm-keyword:hover {
            background: linear-gradient(135deg, #fde047 0%, #f59e0b 100%);
            color: white;
        }
        .static-term {
            background: #e5e7eb;
            border: 1px solid #d1d5db;
        }
        .static-term:hover {
            background: #d1d5db;
        }
        .chat-message {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .definition-card {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 1px solid #cbd5e1;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body class="bg-gray-50 h-screen overflow-hidden">
    <div class="flex h-full">
        <!-- Left Side: Timeline (Full Height) -->
        <div class="w-2/3 flex flex-col h-full">
            <!-- Header with Navigation -->
            <div class="bg-white border-b p-4 flex justify-between items-center">
                <div class="flex items-center gap-3">
                    <h1 class="text-xl font-semibold text-gray-800">ğŸ“ ä¼šè®®æ—¶é—´çº¿å›æ”¾</h1>
                    <span id="currentTranscriptInfo" class="text-sm text-gray-500 hidden bg-gray-100 px-2 py-1 rounded"></span>
                </div>
                <div class="flex items-center gap-2">
                    <button onclick="showHistoryPage()" class="px-3 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors text-sm">
                        ğŸ“š å†å²è®°å½•
                    </button>
                    <button onclick="showSettingsModal()" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors text-sm">
                        âš™ï¸ è®¾ç½®
                    </button>
                    <button onclick="showPasteModal()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                        ğŸ“‹ ç²˜è´´è½¬å½•
                    </button>
                </div>
            </div>

            <!-- Timeline Controls -->
            <div class="bg-white border-b p-4">
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center gap-2">
                        <button onclick="togglePlay()" id="playBtn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                            â–¶ï¸ æ’­æ”¾
                        </button>
                        <button onclick="reset()" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                            ğŸ”„ é‡ç½®
                        </button>
                        <span class="text-sm text-gray-600">è‡ªåŠ¨æ’­æ”¾é—´éš”: 25ç§’</span>
                        <span id="llmIndicator" class="hidden text-sm text-orange-600 flex items-center gap-1">
                            <div class="animate-spin w-3 h-3 border border-orange-600 border-t-transparent rounded-full"></div>
                            <span>AI åˆ†æä¸­...</span>
                        </span>
                    </div>
                    <div class="text-sm text-gray-600">
                        è¿›åº¦: <span id="progress">0/0</span> â€¢ AIå…³é”®è¯: <span id="keywordCount">0</span>
                    </div>
                </div>
                
                <!-- Timeline Scrubber -->
                <div class="flex items-center gap-3">
                    <span id="currentTime" class="text-sm font-mono text-gray-500 w-12">0:00</span>
                    <input type="range" id="timeline" min="0" max="300" value="0" class="flex-1 h-2" oninput="seekTo(this.value)">
                    <span id="maxTime" class="text-sm font-mono text-gray-500 w-12">5:00</span>
                </div>
            </div>

            <!-- Transcript Timeline -->
            <div id="transcriptContainer" class="flex-1 overflow-y-auto p-4 custom-scrollbar">
                <div id="transcript" class="space-y-3">
                    <!-- Timeline segments will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Right Side: Definitions + Chat -->
        <div class="w-1/3 flex flex-col h-full border-l">
            <!-- Top: Definitions -->
            <div class="h-1/2 flex flex-col">
                <div class="bg-white border-b p-4">
                    <h2 class="text-lg font-semibold text-gray-800">ğŸ“– æœ¯è¯­å®šä¹‰</h2>
                </div>
                <div class="flex-1 overflow-y-auto p-4 custom-scrollbar">
                    <div id="definitionContent">
                        <div class="text-sm text-gray-500 text-center py-8">
                            ç‚¹å‡»å·¦ä¾§é«˜äº®æœ¯è¯­æŸ¥çœ‹å®šä¹‰
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom: Chat -->
            <div class="h-1/2 flex flex-col border-t">
                <div class="bg-white border-b p-4">
                    <h2 class="text-lg font-semibold text-gray-800">ğŸ’¬ ä¼šè®®é—®ç­”</h2>
                </div>
                <div class="flex-1 overflow-y-auto p-4 custom-scrollbar">
                    <div id="chatMessages" class="space-y-3">
                        <div class="text-sm text-gray-500 text-center py-4">
                            è¯¢é—®å…³äºæœ¬æ¬¡ä¼šè®®çš„ä»»ä½•é—®é¢˜...
                        </div>
                    </div>
                </div>
                <div class="bg-white border-t p-4">
                    <div class="flex gap-2">
                        <input 
                            type="text" 
                            id="chatInput" 
                            placeholder="é—®é—®å…³äºè¿™æ¬¡ä¼šè®®..." 
                            class="flex-1 border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            onkeypress="if(event.key==='Enter') askQuestion()"
                        >
                        <button onclick="askQuestion()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                            å‘é€
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- History Page -->
    <div id="historyPage" class="fixed inset-0 bg-gray-100 z-40 hidden">
        <div class="h-full flex flex-col">
            <!-- History Header -->
            <div class="bg-white border-b p-4">
                <div class="flex justify-between items-center max-w-6xl mx-auto">
                    <div class="flex items-center gap-3">
                        <button onclick="showAgentPage()" class="px-3 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                            â† è¿”å›åŠ©æ‰‹
                        </button>
                        <h1 class="text-2xl font-bold text-gray-900">ä¼šè®®å†å²è®°å½•</h1>
                        <span id="transcriptCount" class="text-sm text-gray-500 bg-gray-100 px-2 py-1 rounded">0 ä¸ªè½¬å½•</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <button onclick="loadAllTranscriptions()" class="px-3 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors text-sm">
                            ğŸ”„ åˆ·æ–°åˆ—è¡¨
                        </button>
                        <button onclick="showPasteModal()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                            ğŸ“ æ–°å¢è½¬å½•
                        </button>
                    </div>
                </div>
            </div>

            <!-- History Content -->
            <div class="flex-1 overflow-y-auto p-6">
                <div class="max-w-6xl mx-auto">
                    <div id="transcriptionsList" class="grid gap-4">
                        <div class="text-center py-12 text-gray-500">
                            <div class="text-4xl mb-4">ğŸ“š</div>
                            <p class="text-lg">æ­£åœ¨åŠ è½½ä¼šè®®å†å²...</p>
                            <p class="text-sm mt-2">ç³»ç»Ÿå°†è‡ªåŠ¨æ£€æµ‹å¹¶åŠ è½½æ‰€æœ‰å¯ç”¨çš„è½¬å½•æ–‡ä»¶</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Paste Modal -->
    <div id="pasteModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 w-full max-w-3xl m-4 max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">ğŸ“‹ ç²˜è´´é£ä¹¦ä¼šè®®è½¬å½•</h3>
                <button onclick="closePasteModal()" class="text-gray-500 hover:text-gray-700 text-xl">âœ•</button>
            </div>
            <div class="mb-4">
                <div class="text-sm text-gray-600 mb-2">æ”¯æŒçš„æ ¼å¼:</div>
                <div class="bg-gray-50 rounded-lg p-3 text-sm font-mono text-gray-700">
                    æ±¤æ¬£é’° 00:00<br>
                    ä¼šè®®å†…å®¹...<br><br>
                    è¯´è¯äºº 1 01:30<br>
                    æ›´å¤šå†…å®¹...
                </div>
            </div>
            <textarea 
                id="pasteArea" 
                class="flex-1 border rounded-lg p-4 font-mono text-sm resize-none focus:outline-none focus:ring-2 focus:ring-blue-500" 
                placeholder="åœ¨æ­¤ç²˜è´´å®Œæ•´çš„é£ä¹¦ä¼šè®®è½¬å½•æ–‡æœ¬..."
            ></textarea>
            <div class="flex justify-end gap-3 mt-4">
                <button onclick="closePasteModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition-colors">
                    å–æ¶ˆ
                </button>
                <button onclick="loadTranscript()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    åŠ è½½è½¬å½•
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 w-full max-w-md m-4">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-semibold">âš™ï¸ AI å®šä¹‰è®¾ç½®</h3>
                <button onclick="closeSettingsModal()" class="text-gray-500 hover:text-gray-700 text-xl">âœ•</button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Mify API Key</label>
                    <input 
                        type="password" 
                        id="apiKeyInput" 
                        placeholder="è¾“å…¥æ‚¨çš„ Mify API Key"
                        class="w-full border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                    <div class="text-xs text-gray-500 mt-1">
                        API Key å°†å®‰å…¨å­˜å‚¨åœ¨æµè§ˆå™¨æœ¬åœ°ï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨
                    </div>
                </div>
                
                <div class="bg-blue-50 rounded-lg p-3">
                    <div class="text-sm text-blue-800">
                        <strong>åŠŸèƒ½è¯´æ˜:</strong> é…ç½® API Key åï¼Œç‚¹å‡»æœ¯è¯­å°†è‡ªåŠ¨è°ƒç”¨ AI ç”Ÿæˆä¸Šä¸‹æ–‡ç›¸å…³çš„æ™ºèƒ½å®šä¹‰
                    </div>
                </div>
                
                <div id="apiStatus" class="hidden">
                    <!-- API status will be shown here -->
                </div>
            </div>
            
            <div class="flex justify-end gap-3 mt-6">
                <button onclick="clearApiKey()" class="px-4 py-2 bg-red-100 text-red-700 rounded-lg hover:bg-red-200 transition-colors text-sm">
                    æ¸…é™¤ Key
                </button>
                <button onclick="testApiKey()" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors text-sm">
                    æµ‹è¯•è¿æ¥
                </button>
                <button onclick="saveApiKey()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    ä¿å­˜è®¾ç½®
                </button>
            </div>
        </div>
    </div>

    <script>
        // Sample data
        const sampleTranscript = \`æ±¤æ¬£é’° 00:00
çŒ«æˆ´åœ¨èº«ä¸Šï¼Œç„¶ååˆæœ‰å®šä½ï¼Œåˆæœ‰ç³–åŒ…ä¸ç¿»è¯‘ã€‚å—¯ï¼Œå»å¹´å¥½åƒå°±æœ‰è¿™ä¸ªï¼Œå¥½åƒå°±æœ‰ä¸€ä¸ªï¼Œå»å¹´å¥½åƒæœ‰ä¸€ä¸ªç±»ä¼¼çš„ï¼Œå°±æ˜¯ä¹Ÿæˆ´åœ¨ä»€ä¹ˆèº«ä¸Šå•Šï¼Ÿç‹—å•Šï¼Ÿå¯¹å•Šï¼Œé‚£ä¸ªç½‘ç«™çš„å“ªé‡Œå•Šï¼Ÿé‚£ä¸ªæœ‰æ²¡æœ‰æ€»çš„é‚£ä¸ª listï¼Ÿå¦‚æœå•ç‹¬å‘ä¸€ä¸ªï¼ŒOKï¼Œæˆ‘æ¥å‘ä¸€ä¸ªè¿™ç§çš„ listï¼Œå…ˆï¼Œè¿™ä¸ªå…ˆåˆ°ï¼Œæˆ‘å‘ä¹Ÿè¡Œï¼Œå¼ è€å¸ˆä¸ç”¨å‘ã€‚

æ±¤æ¬£é’° 00:56
ç„¶åï¼Œå—¯ï¼Œè¦ä¸ç„¶æˆ‘ä»¬å…ˆè¯´ï¼Œå—¯ï¼Œå°±æ˜å¤©ï¼Œä¸æ˜¯è¿˜æ˜¯ä¸‹åˆæœ‰é‚£ä¸ªå‘¨ä¼šå˜›ï¼Ÿå—¯ï¼Œå¯¹ï¼Œå°±å¤§å®¶æœ€è¿‘æœ‰æ²¡æœ‰ä»€ä¹ˆå›°éš¾ï¼Ÿç„¶åä»¥åŠæœ‰æ²¡æœ‰è¯†åˆ«åˆ°ä»€ä¹ˆæœºä¼šã€æƒ³æ³•çš„ï¼Ÿç„¶åå…¶ä»–çš„å°±æ˜¯ä¾‹è¡Œçš„ï¼Œæ¯”å¦‚åœ¨ä¼šä¸Šå°±ä¾‹è¡ŒåŒæ­¥äº†ã€‚ä¸»è¦æ˜¯æˆ‘è§‰å¾—å¤§ä¼šå‰æ²¡æœ‰ä»€ä¹ˆè¦å†³ç­–çš„ã€‚å¯¹ï¼Œä¸€ä¸ªæ˜¯é‚£ä¸ªæˆ‘çŸ¥é“çš„ï¼Œä¸€ä¸ªæ˜¯å¿—æ—­é‚£è¾¹ï¼Œå¯¹å§ï¼Ÿä»–æ‰‹æœºæµ‹è¿™ä¸ªå¼€å‘çš„èµ„æºï¼Œæˆ–è€…è¯´è¿™ç§èƒ½åŠ›æˆ‘ä»¬è¿˜æ¯”è¾ƒçŸ­ç¼ºä¸€äº›ï¼Œæ˜¯å§ï¼Ÿè¡Œï¼Œè¿™ä¸ªæ˜¯å·²ç»çŸ¥é“äº†ã€‚

æ±¤æ¬£é’° 01:36
å¯¹ï¼Œæˆ‘çœ‹è¿™ä¸ªé»‘é©¬é¡¹ç›®ä»–ä»¬éƒ½æœ‰åœ¨å…¨æ· OA ä¸Šéƒ¨ç½²ä¸€äº› 1.5B çš„ç«¯è§‚æµ‹æ¨¡å‹ã€‚å—¯ï¼Œå®Œå…¨æ˜¯æ¯”æˆ‘ä»¬è¿™ä¸ªå‚æ•°é‡è¦å¤§å¾—å¤šï¼Œç„¶åå¥½åƒè¿˜è¡Œï¼Œé‚£å¯ä»¥è”ç³»ä¸‹ä»–ä»¬ï¼Œæ˜¯å§ï¼Ÿåæ­£å°±æ˜¯é‚£ä¸ªé»‘é©¬ï¼Œè¿™ä¸ªé©¬æ‹‰æ¾ä¸Šï¼Œå¯¹ï¼Œæˆ‘è§‰å¾—å¯èƒ½é‚£äº›äººä¹Ÿå¾ˆé‡è¦ï¼Œçœ‹å“ªäº›äººæœ‰æ„æ€ï¼Œç„¶åè·Ÿä»–ä»¬èŠä¸€èŠã€‚

æ±¤æ¬£é’° 02:04
ä½ è¿™ä¸ªçŸ¥é“ï¼Œç„¶åæˆ‘å†é—®ä¸€ä¸‹è¿™è¾¹çš„ Buzzï¼Œæ˜¯å§ï¼Ÿç„¶åæˆ‘ä¹Ÿç•™äº†ã€‚é‚£ä¸ªè¿˜æœ‰æ²¡æœ‰ä»€ä¹ˆå›°éš¾å•Šï¼Ÿæœ‰æ²¡æœ‰å¤§å®¶è§‰å¾—é‡åˆ°ä¸€äº›å›°éš¾çš„ï¼Ÿå¯¹ã€‚å—¯ï¼Œæœ‰ä¸ªæ¯”è¾ƒå¤§çš„å›°éš¾ï¼Œå°±è·Ÿä¸Šå¤´èŠçš„é‚£ä¸ªéšç§æ¨¡å¼ï¼Œå…¶å®æ„Ÿè§‰æ²¡æœ‰ç‰¹åˆ«å¥½çš„æ€è·¯ã€‚å—¯ï¼Œä½†æ˜¯æˆ‘åˆå›å½’åˆ°é‚£ä¸ªçœ¼é•œé—®é¢˜ï¼Œå› ä¸ºä¹‹å‰è°·æ­Œä»–ä»¬ä¸æ˜¯ä¹Ÿé‡åˆ°å¾ˆéš¾è§£é‡Šçš„é—®é¢˜å˜›ï¼Ÿå—¯ï¼Œç„¶åå›é¡¾äº†ä¸€ä¸‹é›·æœ‹çš„è§£æ³•ï¼Œé‚£ä¸ª Meta çš„è§£æ³•ï¼Œä½†æ˜¯åˆ°å’±ä»¬è¿™å—ï¼Œè¯­éŸ³ç›¸å…³çš„é‚£ä¸ªäººè¿˜æ²¡æœ‰ç‰¹åˆ«å¥½çš„ä¸€ä¸ªã€‚è¡Œï¼Œè¿™ä¸ªå¾…ä¼šæˆ‘ä»¬å†è¯´ã€‚è¡Œï¼Œè¿™ä¸ªåŒå­¦å¤§æ¦‚çŸ¥é“äº†ã€‚

æ±¤æ¬£é’° 02:55
æˆ‘æ‹¿å¾—åˆ°çš„å“¦ã€‚æˆ‘å·²ç»åœ¨å½•äº†ï¼Œæˆ‘ä¹ŸæŠŠå®ƒæ“ï¼Œæˆ‘çœ‹æˆ‘æŠŠè¿™ä¸ªåˆ†äº«åˆ°ç¾¤é‡Œã€‚\`;

        // State
        let segments = [];
        let currentIndex = -1;
        let isPlaying = false;
        let playInterval;
        let allTerms = new Map(); // term -> {count, occurrences, contexts}
        let selectedTerm = null;
        
        // Real-time LLM keyword tracking
        let llmKeywords = new Map(); // keyword -> {definition, segments, confidence}
        let lastLLMCallIndex = -1; // Track when we last called LLM
        let keywordCallInProgress = false;
        
        // Multi-transcription support
        let allTranscriptions = new Map(); // filename -> {metadata, content, parsed}
        let currentTranscriptionId = null;
        let currentView = 'agent'; // 'agent' or 'history'

        // Parse functions
        function parseTime(timeStr) {
            const [min, sec] = timeStr.split(':').map(Number);
            return min * 60 + sec;
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return \`\${min}:\${sec.toString().padStart(2, '0')}\`;
        }

        function parseTranscript(text) {
            const lines = text.split('\\n').filter(line => line.trim());
            const result = [];
            const speakerPattern = /^(.+?)\\s+(\\d{1,2}:\\d{2})$/;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const match = line.match(speakerPattern);
                
                if (match) {
                    const speaker = match[1];
                    const time = match[2];
                    const timeSeconds = parseTime(time);
                    
                    let content = '';
                    let j = i + 1;
                    while (j < lines.length && !lines[j].match(speakerPattern)) {
                        if (content) content += ' ';
                        content += lines[j].trim();
                        j++;
                    }
                    
                    if (content) {
                        result.push({ 
                            speaker, 
                            time, 
                            timeSeconds, 
                            content, 
                            index: result.length 
                        });
                    }
                    i = j - 1;
                }
            }
            return result;
        }

        // Term extraction
        function extractTerms(segments) {
            const termMap = new Map();
            
            segments.forEach((seg, segIndex) => {
                // Technical compound terms
                const patterns = [
                    /([\u4e00-\u9fa5]{2,4})(é¡¹ç›®|æ¨¡å‹|æ¨¡å¼|ç³»ç»Ÿ|å¹³å°|ç®—æ³•|æ–¹æ¡ˆ|äº§å“|è®¾å¤‡|çœ¼é•œ|æ‰‹ç¯|å½•éŸ³)/g,
                    /(\\d+\\.?\\d*[BM]?)\\s*(æ¨¡å‹|å‚æ•°|ç‰ˆæœ¬)/g,
                    /\\b(Meta|Google|è°·æ­Œ|è‹¹æœ|å°ç±³|é›·æœ‹|Buzz|OA|Take\\s*Note)\\b/gi,
                    /(äººå·¥æ™ºèƒ½|æœºå™¨å­¦ä¹ |æ·±åº¦å­¦ä¹ |å¤§æ¨¡å‹|ç«¯ä¾§|äº‘ç«¯|éšç§|å®‰å…¨|è¯­éŸ³è¯†åˆ«|è‡ªç„¶è¯­è¨€|æ•°æ®|ç®—åŠ›)/g
                ];
                
                patterns.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(seg.content)) !== null) {
                        const term = match[0];
                        if (termMap.has(term)) {
                            const info = termMap.get(term);
                            info.count++;
                            info.occurrences.push(segIndex);
                            if (info.contexts.length < 3) {
                                info.contexts.push(seg.content.substring(0, 100) + '...');
                            }
                        } else {
                            termMap.set(term, {
                                term,
                                count: 1,
                                firstIndex: segIndex,
                                occurrences: [segIndex],
                                contexts: [seg.content.substring(0, 100) + '...']
                            });
                        }
                    }
                });
            });
            
            // Filter terms (keep if appears more than once OR looks important)
            for (const [term, info] of termMap.entries()) {
                const looksImportant = 
                    /\\d+\\.?\\d*[BM]/.test(term) || // Technical numbers
                    /(é¡¹ç›®|æ¨¡å‹|æ¨¡å¼|ç³»ç»Ÿ|å¹³å°|ç®—æ³•|æ–¹æ¡ˆ|äº§å“|è®¾å¤‡)$/.test(term) || // Compound terms
                    /^(Meta|Google|è°·æ­Œ|è‹¹æœ|å°ç±³|é›·æœ‹|Buzz|OA|Take\\s*Note)$/i.test(term); // Brands
                
                if (info.count < 2 && !looksImportant) {
                    termMap.delete(term);
                }
            }
            
            return termMap;
        }

        // Real-time LLM keyword analysis
        async function checkForLLMKeywordAnalysis() {
            // Call LLM every ~1 minute (approximately 3 segments at 25s each)
            const segmentsSinceLastCall = currentIndex - lastLLMCallIndex;
            
            if (segmentsSinceLastCall >= 3 && !keywordCallInProgress) {
                await performLLMKeywordAnalysis();
            }
        }

        async function performLLMKeywordAnalysis() {
            if (keywordCallInProgress) return;
            
            const apiKey = localStorage.getItem('mify_api_key');
            if (!apiKey) {
                console.log('No API key configured for LLM keyword analysis');
                return;
            }

            keywordCallInProgress = true;
            lastLLMCallIndex = currentIndex;
            
            // Show AI analysis indicator
            document.getElementById('llmIndicator').classList.remove('hidden');

            try {
                // Get recent segments for analysis (last 3 segments)
                const recentSegments = segments.slice(Math.max(0, currentIndex - 2), currentIndex + 1);
                const contextText = recentSegments.map(seg => 
                    \`[\${seg.time}] \${seg.speaker}: \${seg.content}\`
                ).join('\\n\\n');

                console.log('Analyzing keywords for segments:', recentSegments.map(s => s.index));

                const keywords = await identifyKeywordsWithLLM(contextText, recentSegments);
                
                // Store keywords with their definitions
                keywords.forEach(kw => {
                    llmKeywords.set(kw.keyword, {
                        definition: kw.definition,
                        segments: recentSegments.map(s => s.index),
                        confidence: kw.confidence || 0.8
                    });
                });

                // Re-render transcript with new keywords
                renderTranscript();
                
                // Update keyword count
                document.getElementById('keywordCount').textContent = llmKeywords.size;
                
                console.log('Identified keywords:', keywords.map(k => k.keyword));
                
            } catch (error) {
                console.error('LLM keyword analysis failed:', error);
            } finally {
                keywordCallInProgress = false;
                // Hide AI analysis indicator
                document.getElementById('llmIndicator').classList.add('hidden');
            }
        }

        async function identifyKeywordsWithLLM(contextText, segments) {
            const apiKey = localStorage.getItem('mify_api_key');
            
            const prompt = \`ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ä¼šè®®åŠ©æ‰‹ã€‚è¯·åˆ†æä»¥ä¸‹ä¼šè®®ç‰‡æ®µï¼Œè¯†åˆ«å‡ºå…³é”®è¯å¹¶ä¸ºæ¯ä¸ªå…³é”®è¯æä¾›ç®€æ´çš„ä¸€è¡Œå®šä¹‰ã€‚

ä¼šè®®ç‰‡æ®µ:
\${contextText}

è¦æ±‚:
1. è¯†åˆ«3-8ä¸ªæœ€é‡è¦çš„å…³é”®è¯
2. ä¼˜å…ˆé€‰æ‹©ï¼šæŠ€æœ¯æœ¯è¯­ã€é¡¹ç›®åç§°ã€äº§å“åç§°ã€é‡è¦æ¦‚å¿µ
3. ä¸ºæ¯ä¸ªå…³é”®è¯æä¾›ä¸€è¡Œç®€æ´å®šä¹‰ï¼ˆä¸è¶…è¿‡30å­—ï¼‰
4. è¿”å›JSONæ ¼å¼ï¼ŒåŒ…å«keywordå’Œdefinitionå­—æ®µ

è¯·è¿”å›JSONæ ¼å¼:
{
  "keywords": [
    {"keyword": "å…³é”®è¯1", "definition": "ç®€æ´å®šä¹‰1"},
    {"keyword": "å…³é”®è¯2", "definition": "ç®€æ´å®šä¹‰2"}
  ]
}\`;

            const response = await fetch(MIFY_CONFIG.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': \`Bearer \${apiKey}\`,
                    'api-key': apiKey
                },
                body: JSON.stringify({
                    model: MIFY_CONFIG.model,
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.7,
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                throw new Error(\`API call failed: \${response.status}\`);
            }

            const data = await response.json();
            const content = data.choices[0].message.content.trim();
            
            try {
                // Extract JSON from response
                const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);
                if (!jsonMatch) {
                    throw new Error('No JSON found in response');
                }
                
                const parsed = JSON.parse(jsonMatch[0]);
                return parsed.keywords || [];
                
            } catch (parseError) {
                console.error('Failed to parse LLM response:', content);
                return [];
            }
        }

        // Enhanced highlighting with LLM keywords
        function highlightTerms(text) {
            let result = text;
            
            // First highlight LLM-identified keywords (priority)
            const llmKeys = Array.from(llmKeywords.keys()).sort((a, b) => b.length - a.length);
            llmKeys.forEach(keyword => {
                const escapedTerm = keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');
                const regex = new RegExp(\`(\${escapedTerm})\`, 'gi');
                result = result.replace(regex, \`<span class="highlight llm-keyword" onclick="selectLLMKeyword('\$1')" title="AIè¯†åˆ«å…³é”®è¯">\$1</span>\`);
            });
            
            // Then highlight static terms (lower priority)
            const staticTerms = Array.from(allTerms.keys()).sort((a, b) => b.length - a.length);
            staticTerms.forEach(term => {
                // Skip if already highlighted by LLM
                if (llmKeys.some(k => k.toLowerCase() === term.toLowerCase())) return;
                
                const escapedTerm = term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');
                const regex = new RegExp(\`(\${escapedTerm})\`, 'gi');
                result = result.replace(regex, \`<span class="highlight static-term" onclick="selectTerm('\$1')" title="æ¨¡å¼åŒ¹é…æœ¯è¯­">\$1</span>\`);
            });
            
            return result;
        }

        // Mify LLM API configuration
        const MIFY_CONFIG = {
            apiUrl: 'https://service.mify.mioffice.cn/v1/chat/completions',
            apiKey: '', // Will be set from user input or environment
            model: 'gpt-4o-mini'
        };

        // Term selection with LLM-powered definitions
        async function selectTerm(term) {
            selectedTerm = term;
            const termInfo = allTerms.get(term);
            if (!termInfo) return;
            
            // Show loading state
            showLoadingDefinition(term, termInfo);
            
            try {
                // Generate AI-powered definition
                const llmDefinition = await generateLLMDefinition(term, termInfo);
                showLLMDefinition(term, termInfo, llmDefinition);
            } catch (error) {
                console.error('LLM definition failed:', error);
                showFallbackDefinition(term, termInfo, error.message);
            }
        }

        function showLoadingDefinition(term, termInfo) {
            const definitionHtml = \`
                <div class="definition-card rounded-lg p-4">
                    <div class="flex items-center gap-3 mb-4">
                        <h3 class="font-semibold text-lg text-gray-800">\${term}</h3>
                        <div class="flex items-center gap-2 text-sm text-blue-600">
                            <div class="animate-spin w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                            <span>AI ç”Ÿæˆä¸­...</span>
                        </div>
                    </div>
                    <div class="text-sm text-gray-600 mb-4">
                        å…±å‡ºç° <span class="font-semibold text-blue-600">\${termInfo.count}</span> æ¬¡ï¼Œæ­£åœ¨åˆ†æä¸Šä¸‹æ–‡...
                    </div>
                    <div class="bg-gray-50 rounded-lg p-4 text-center text-gray-500">
                        ğŸ¤– æ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆæ™ºèƒ½å®šä¹‰...
                    </div>
                    <div class="mt-4">
                        <h4 class="font-medium text-gray-700 mb-2">å‡ºç°ä½ç½®:</h4>
                        <div class="flex flex-wrap gap-1">
                            \${termInfo.occurrences.map(idx => 
                                \`<button onclick="jumpToSegment(\${idx})" class="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors">
                                    #\${idx + 1} Â· \${segments[idx] ? segments[idx].time : ''}
                                </button>\`
                            ).join('')}
                        </div>
                    </div>
                </div>
            \`;
            document.getElementById('definitionContent').innerHTML = definitionHtml;
        }

        function showLLMDefinition(term, termInfo, llmDefinition) {
            const definitionHtml = \`
                <div class="definition-card rounded-lg p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold text-lg text-gray-800">\${term}</h3>
                        <div class="flex items-center gap-1 text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">
                            <span>ğŸ¤–</span>
                            <span>AI å®šä¹‰</span>
                        </div>
                    </div>
                    
                    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4 mb-4 border-l-4 border-blue-400">
                        <div class="text-sm leading-relaxed text-gray-800">
                            \${llmDefinition.replace(/\\n/g, '<br>')}
                        </div>
                    </div>
                    
                    <div class="text-xs text-gray-500 mb-4 flex items-center gap-2">
                        <span>ğŸ“Š</span>
                        <span>ä¼šè®®ä¸­å‡ºç° \${termInfo.count} æ¬¡</span>
                        <span>â€¢</span>
                        <span>åŸºäºä¸Šä¸‹æ–‡æ™ºèƒ½åˆ†æ</span>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-gray-700 mb-2">å‡ºç°ä½ç½®:</h4>
                        <div class="flex flex-wrap gap-1">
                            \${termInfo.occurrences.map(idx => 
                                \`<button onclick="jumpToSegment(\${idx})" class="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors">
                                    #\${idx + 1} Â· \${segments[idx] ? segments[idx].time : ''}
                                </button>\`
                            ).join('')}
                        </div>
                    </div>
                </div>
            \`;
            document.getElementById('definitionContent').innerHTML = definitionHtml;
        }

        function showFallbackDefinition(term, termInfo, errorMessage) {
            const definitionHtml = \`
                <div class="definition-card rounded-lg p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold text-lg text-gray-800">\${term}</h3>
                        <div class="flex items-center gap-1 text-xs bg-yellow-100 text-yellow-700 px-2 py-1 rounded-full">
                            <span>âš ï¸</span>
                            <span>åŸºç¡€å®šä¹‰</span>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4">
                        <div class="text-sm text-yellow-800 mb-2">
                            <strong>AI æœåŠ¡æš‚ä¸å¯ç”¨</strong> (\${errorMessage})
                        </div>
                        <div class="text-sm text-gray-700">
                            è¿™æ˜¯ä¼šè®®ä¸­æåˆ°çš„é‡è¦æœ¯è¯­ã€‚æ ¹æ®ä¸Šä¸‹æ–‡åˆ†æï¼Œ"\${term}" åœ¨æŠ€æœ¯è®¨è®ºä¸­è¢«å¤šæ¬¡æåŠï¼Œå¯èƒ½æ¶‰åŠé¡¹ç›®åç§°ã€æŠ€æœ¯æ¦‚å¿µæˆ–äº§å“åŠŸèƒ½ã€‚
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="font-medium text-gray-700 mb-2">ä¸Šä¸‹æ–‡ç‰‡æ®µ:</h4>
                        <div class="space-y-2">
                            \${termInfo.contexts.slice(0, 2).map(context => 
                                \`<div class="bg-white rounded p-3 text-sm border-l-4 border-gray-200">\${context}</div>\`
                            ).join('')}
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-gray-700 mb-2">å‡ºç°ä½ç½®:</h4>
                        <div class="flex flex-wrap gap-1">
                            \${termInfo.occurrences.map(idx => 
                                \`<button onclick="jumpToSegment(\${idx})" class="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors">
                                    #\${idx + 1} Â· \${segments[idx] ? segments[idx].time : ''}
                                </button>\`
                            ).join('')}
                        </div>
                    </div>
                </div>
            \`;
            document.getElementById('definitionContent').innerHTML = definitionHtml;
        }

        async function generateLLMDefinition(term, termInfo) {
            // Get API key from localStorage or prompt user
            let apiKey = localStorage.getItem('mify_api_key');
            if (!apiKey) {
                apiKey = prompt('è¯·è¾“å…¥ Mify API Key (å°†å®‰å…¨å­˜å‚¨åœ¨æœ¬åœ°):');
                if (!apiKey) {
                    throw new Error('éœ€è¦ API Key æ‰èƒ½ä½¿ç”¨ AI å®šä¹‰åŠŸèƒ½');
                }
                localStorage.setItem('mify_api_key', apiKey);
            }

            // Prepare context from meeting segments
            const contextSegments = termInfo.occurrences.slice(0, 3).map(idx => {
                const seg = segments[idx];
                return \`[\${seg.time}] \${seg.speaker}: \${seg.content}\`;
            }).join('\\n\\n');

            const prompt = \`ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ä¼šè®®åŠ©æ‰‹ã€‚è¯·åŸºäºä»¥ä¸‹ä¼šè®®å†…å®¹ï¼Œä¸ºæœ¯è¯­"\${term}"æä¾›ä¸€ä¸ªå‡†ç¡®ã€ç®€æ´çš„å®šä¹‰ã€‚

ä¼šè®®ä¸Šä¸‹æ–‡:
\${contextSegments}

è¦æ±‚:
1. æ ¹æ®ä¼šè®®ä¸Šä¸‹æ–‡ç†è§£è¯¥æœ¯è¯­çš„å…·ä½“å«ä¹‰
2. æä¾›ç®€æ´ä½†è¯¦ç»†çš„å®šä¹‰ï¼ˆ2-3å¥è¯ï¼‰
3. å¦‚æœæ˜¯æŠ€æœ¯æœ¯è¯­ï¼Œè§£é‡Šå…¶åœ¨ä¼šè®®è®¨è®ºä¸­çš„ä½œç”¨
4. å¦‚æœæ˜¯é¡¹ç›®/äº§å“åç§°ï¼Œè¯´æ˜å…¶ä¸»è¦åŠŸèƒ½æˆ–ç‰¹ç‚¹
5. ç”¨ä¸­æ–‡å›ç­”ï¼Œè¯­è¨€ä¸“ä¸šä½†æ˜“æ‡‚

è¯·ä¸º"\${term}"æä¾›å®šä¹‰:\`;

            const response = await fetch(MIFY_CONFIG.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': \`Bearer \${apiKey}\`,
                    'api-key': apiKey
                },
                body: JSON.stringify({
                    model: MIFY_CONFIG.model,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 300
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(\`API è°ƒç”¨å¤±è´¥: \${response.status} - \${errorText}\`);
            }

            const data = await response.json();
            
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('API å“åº”æ ¼å¼é”™è¯¯');
            }

            return data.choices[0].message.content.trim();
        }

        // Handle clicks on LLM-identified keywords
        function selectLLMKeyword(keyword) {
            selectedTerm = keyword;
            const keywordInfo = llmKeywords.get(keyword);
            
            if (!keywordInfo) {
                console.error('LLM keyword not found:', keyword);
                return;
            }

            const definitionHtml = \`
                <div class="definition-card rounded-lg p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold text-lg text-gray-800">\${keyword}</h3>
                        <div class="flex items-center gap-1 text-xs bg-gradient-to-r from-yellow-100 to-orange-100 text-orange-700 px-2 py-1 rounded-full border border-orange-200">
                            <span>ğŸ§ </span>
                            <span>AI å®æ—¶è¯†åˆ«</span>
                        </div>
                    </div>
                    
                    <div class="bg-gradient-to-r from-yellow-50 to-orange-50 rounded-lg p-4 mb-4 border-l-4 border-orange-400">
                        <div class="text-sm leading-relaxed text-gray-800 font-medium">
                            \${keywordInfo.definition}
                        </div>
                    </div>
                    
                    <div class="text-xs text-gray-500 mb-4 flex items-center gap-2">
                        <span>âš¡</span>
                        <span>å®æ—¶åˆ†æè¯†åˆ«</span>
                        <span>â€¢</span>
                        <span>ç½®ä¿¡åº¦: \${Math.round(keywordInfo.confidence * 100)}%</span>
                        <span>â€¢</span>
                        <span>æ¶‰åŠ \${keywordInfo.segments.length} ä¸ªç‰‡æ®µ</span>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-gray-700 mb-2">ç›¸å…³ç‰‡æ®µ:</h4>
                        <div class="flex flex-wrap gap-1">
                            \${keywordInfo.segments.map(idx => 
                                \`<button onclick="jumpToSegment(\${idx})" class="text-xs px-2 py-1 bg-orange-100 text-orange-700 rounded hover:bg-orange-200 transition-colors border border-orange-200">
                                    #\${idx + 1} Â· \${segments[idx] ? segments[idx].time : ''}
                                </button>\`
                            ).join('')}
                        </div>
                    </div>
                </div>
            \`;
            
            document.getElementById('definitionContent').innerHTML = definitionHtml;
        }

        function jumpToSegment(index) {
            currentIndex = index;
            renderTranscript();
            updateTimeline();
            
            // Scroll to the segment
            const segment = document.querySelector(\`[data-index="\${index}"]\`);
            if (segment) {
                segment.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Rendering
        function renderTranscript() {
            const container = document.getElementById('transcript');
            container.innerHTML = '';
            
            segments.forEach((seg, index) => {
                const div = document.createElement('div');
                div.className = \`timeline-segment p-4 rounded-lg mb-3 \${index <= currentIndex ? 'revealed' : 'hidden'}\`;
                div.setAttribute('data-index', index);
                
                const highlightedContent = highlightTerms(seg.content);
                
                div.innerHTML = \`
                    <div class="flex items-center gap-3 mb-2">
                        <span class="text-xs font-mono text-gray-500 bg-gray-100 px-2 py-1 rounded">\${seg.time}</span>
                        <span class="text-sm font-medium text-gray-700 bg-blue-50 px-3 py-1 rounded-full">\${seg.speaker}</span>
                    </div>
                    <div class="text-sm leading-relaxed text-gray-800">\${highlightedContent}</div>
                \`;
                
                container.appendChild(div);
            });
            
            // Update progress
            document.getElementById('progress').textContent = \`\${Math.max(0, currentIndex + 1)}/\${segments.length}\`;
        }

        // Timeline controls
        function togglePlay() {
            const btn = document.getElementById('playBtn');
            if (isPlaying) {
                clearInterval(playInterval);
                btn.textContent = 'â–¶ï¸ æ’­æ”¾';
                btn.className = 'px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors';
            } else {
                playInterval = setInterval(async () => {
                    if (currentIndex < segments.length - 1) {
                        currentIndex++;
                        renderTranscript();
                        updateTimeline();
                        
                        // Check if we should call LLM for keyword analysis
                        await checkForLLMKeywordAnalysis();
                    } else {
                        togglePlay();
                    }
                }, 25000); // 25 seconds interval
                btn.textContent = 'â¸ï¸ æš‚åœ';
                btn.className = 'px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors';
            }
            isPlaying = !isPlaying;
        }

        function reset() {
            if (isPlaying) togglePlay();
            currentIndex = -1;
            lastLLMCallIndex = -1;
            keywordCallInProgress = false;
            llmKeywords.clear();
            renderTranscript();
            updateTimeline();
            
            // Clear definition panel
            document.getElementById('definitionContent').innerHTML = \`
                <div class="text-sm text-gray-500 text-center py-8">
                    ç‚¹å‡»å·¦ä¾§é«˜äº®æœ¯è¯­æŸ¥çœ‹å®šä¹‰
                </div>
            \`;
        }

        function updateTimeline() {
            const timeline = document.getElementById('timeline');
            const currentTime = document.getElementById('currentTime');
            
            if (segments.length > 0) {
                const maxTime = segments[segments.length - 1].timeSeconds;
                timeline.max = maxTime;
                document.getElementById('maxTime').textContent = formatTime(maxTime);
                
                if (currentIndex >= 0) {
                    timeline.value = segments[currentIndex].timeSeconds;
                    currentTime.textContent = formatTime(segments[currentIndex].timeSeconds);
                } else {
                    timeline.value = 0;
                    currentTime.textContent = '0:00';
                }
            }
        }

        function seekTo(value) {
            const targetTime = parseInt(value);
            currentIndex = segments.findIndex(seg => seg.timeSeconds > targetTime) - 1;
            if (currentIndex < 0) currentIndex = segments.length - 1;
            renderTranscript();
            document.getElementById('currentTime').textContent = formatTime(targetTime);
        }

        // Chat functionality
        function askQuestion() {
            const input = document.getElementById('chatInput');
            const question = input.value.trim();
            if (!question) return;
            
            // Add user message
            addChatMessage('user', question);
            
            // Simulate AI response
            setTimeout(() => {
                const response = generateResponse(question);
                addChatMessage('assistant', response);
            }, 1000);
            
            input.value = '';
        }

        function addChatMessage(role, content) {
            const container = document.getElementById('chatMessages');
            
            // Remove placeholder if it exists
            const placeholder = container.querySelector('.text-center');
            if (placeholder) placeholder.remove();
            
            const div = document.createElement('div');
            div.className = 'chat-message';
            
            if (role === 'user') {
                div.innerHTML = \`
                    <div class="bg-blue-100 rounded-lg p-3 text-sm">
                        <div class="font-medium text-blue-800 mb-1">æ‚¨:</div>
                        <div class="text-blue-700">\${content}</div>
                    </div>
                \`;
            } else {
                div.innerHTML = \`
                    <div class="bg-gray-100 rounded-lg p-3 text-sm">
                        <div class="font-medium text-gray-800 mb-1">åŠ©æ‰‹:</div>
                        <div class="text-gray-700">\${content}</div>
                    </div>
                \`;
            }
            
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function generateResponse(question) {
            // Simple response generation based on question content
            if (question.includes('é¡¹ç›®') || question.includes('é»‘é©¬')) {
                return 'ä¼šè®®ä¸­æåˆ°äº†"é»‘é©¬é¡¹ç›®"ï¼Œä»–ä»¬åœ¨å…¨æ· OA ä¸Šéƒ¨ç½²äº†1.5Bçš„ç«¯è§‚æµ‹æ¨¡å‹ï¼Œå‚æ•°é‡æ¯”ç›®å‰çš„è¦å¤§å¾—å¤šã€‚å¯ä»¥è€ƒè™‘è”ç³»ä»–ä»¬äº†è§£æ›´å¤šç»†èŠ‚ã€‚';
            } else if (question.includes('å›°éš¾') || question.includes('é—®é¢˜')) {
                return 'ä¼šè®®ä¸­æåˆ°çš„ä¸»è¦å›°éš¾åŒ…æ‹¬ï¼š1) æ‰‹æœºå¼€å‘èµ„æºçŸ­ç¼ºï¼›2) éšç§æ¨¡å¼æ²¡æœ‰ç‰¹åˆ«å¥½çš„æ€è·¯ï¼›3) è¯­éŸ³ç›¸å…³çš„è§£å†³æ–¹æ¡ˆè¿˜éœ€è¦å®Œå–„ã€‚';
            } else if (question.includes('æ¨¡å‹') || question.includes('AI')) {
                return 'ä¼šè®®è®¨è®ºäº†1.5Bå‚æ•°çš„ç«¯è§‚æµ‹æ¨¡å‹ï¼Œè¿™æ¯”ç›®å‰ä½¿ç”¨çš„æ¨¡å‹å‚æ•°é‡è¦å¤§å¾—å¤šã€‚è¿˜æåˆ°äº†ç«¯ä¾§æ¨¡å‹çš„éƒ¨ç½²å’Œç›¸å…³æŠ€æœ¯æŒ‘æˆ˜ã€‚';
            } else {
                return 'æ ¹æ®ä¼šè®®å†…å®¹ï¼Œæˆ‘æ‰¾åˆ°äº†ç›¸å…³çš„è®¨è®ºç‰‡æ®µã€‚æ‚¨å¯ä»¥ç‚¹å‡»å·¦ä¾§æ—¶é—´çº¿ä¸­çš„ç›¸å…³éƒ¨åˆ†æŸ¥çœ‹å…·ä½“å†…å®¹ï¼Œæˆ–è€…å°è¯•æ›´å…·ä½“çš„é—®é¢˜ã€‚';
            }
        }

        // Modal functions
        function showPasteModal() {
            document.getElementById('pasteModal').classList.remove('hidden');
            document.getElementById('pasteModal').classList.add('flex');
        }

        function closePasteModal() {
            document.getElementById('pasteModal').classList.add('hidden');
            document.getElementById('pasteModal').classList.remove('flex');
        }

        function loadTranscript() {
            const text = document.getElementById('pasteArea').value.trim();
            if (!text) return;
            
            // Parse and load new transcript
            segments = parseTranscript(text);
            allTerms = extractTerms(segments);
            
            // Reset state
            currentIndex = -1;
            selectedTerm = null;
            lastLLMCallIndex = -1;
            keywordCallInProgress = false;
            llmKeywords.clear();
            
            // Re-render
            renderTranscript();
            updateTimeline();
            
            // Update keyword count
            document.getElementById('keywordCount').textContent = '0';
            
            // Clear definition panel
            document.getElementById('definitionContent').innerHTML = \`
                <div class="text-sm text-gray-500 text-center py-8">
                    ç‚¹å‡»å·¦ä¾§é«˜äº®æœ¯è¯­æŸ¥çœ‹å®šä¹‰
                </div>
            \`;
            
            // Clear chat
            document.getElementById('chatMessages').innerHTML = \`
                <div class="text-sm text-gray-500 text-center py-4">
                    è¯¢é—®å…³äºæœ¬æ¬¡ä¼šè®®çš„ä»»ä½•é—®é¢˜...
                </div>
            \`;
            
            closePasteModal();
            console.log('Loaded transcript:', segments.length, 'segments,', allTerms.size, 'terms');
        }

        // Settings modal functions
        function showSettingsModal() {
            // Load current API key if exists
            const currentKey = localStorage.getItem('mify_api_key');
            if (currentKey) {
                document.getElementById('apiKeyInput').value = currentKey;
            }
            
            document.getElementById('settingsModal').classList.remove('hidden');
            document.getElementById('settingsModal').classList.add('flex');
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.add('hidden');
            document.getElementById('settingsModal').classList.remove('flex');
            document.getElementById('apiStatus').classList.add('hidden');
        }

        function saveApiKey() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (apiKey) {
                localStorage.setItem('mify_api_key', apiKey);
                showApiStatus('success', 'âœ… API Key å·²ä¿å­˜');
            } else {
                showApiStatus('error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ API Key');
            }
        }

        function clearApiKey() {
            localStorage.removeItem('mify_api_key');
            document.getElementById('apiKeyInput').value = '';
            showApiStatus('info', 'ğŸ—‘ï¸ API Key å·²æ¸…é™¤');
        }

        async function testApiKey() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (!apiKey) {
                showApiStatus('error', 'âŒ è¯·å…ˆè¾“å…¥ API Key');
                return;
            }

            showApiStatus('loading', 'ğŸ”„ æ­£åœ¨æµ‹è¯•è¿æ¥...');

            try {
                const response = await fetch(MIFY_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': \`Bearer \${apiKey}\`,
                        'api-key': apiKey
                    },
                    body: JSON.stringify({
                        model: MIFY_CONFIG.model,
                        messages: [{ role: 'user', content: 'æµ‹è¯•è¿æ¥' }],
                        max_tokens: 10
                    })
                });

                if (response.ok) {
                    showApiStatus('success', 'âœ… è¿æ¥æˆåŠŸï¼API Key æœ‰æ•ˆ');
                } else {
                    const errorText = await response.text();
                    showApiStatus('error', \`âŒ è¿æ¥å¤±è´¥: \${response.status}\`);
                }
            } catch (error) {
                showApiStatus('error', \`âŒ ç½‘ç»œé”™è¯¯: \${error.message}\`);
            }
        }

        function showApiStatus(type, message) {
            const statusEl = document.getElementById('apiStatus');
            statusEl.classList.remove('hidden');
            
            let bgColor, textColor;
            switch (type) {
                case 'success':
                    bgColor = 'bg-green-50 border-green-200';
                    textColor = 'text-green-800';
                    break;
                case 'error':
                    bgColor = 'bg-red-50 border-red-200';
                    textColor = 'text-red-800';
                    break;
                case 'loading':
                    bgColor = 'bg-blue-50 border-blue-200';
                    textColor = 'text-blue-800';
                    break;
                default:
                    bgColor = 'bg-gray-50 border-gray-200';
                    textColor = 'text-gray-800';
            }
            
            statusEl.innerHTML = \`
                <div class="rounded-lg p-3 border \${bgColor}">
                    <div class="text-sm \${textColor}">\${message}</div>
                </div>
            \`;
        }

        // Initialize
        function init() {
            console.log('Initializing Post-Meeting Agent...');
            segments = parseTranscript(sampleTranscript);
            allTerms = extractTerms(segments);
            renderTranscript();
            updateTimeline();
            console.log('Ready:', segments.length, 'segments,', allTerms.size, 'terms');
        }

        // Navigation functions
        function showHistoryPage() {
            currentView = 'history';
            document.getElementById('historyPage').classList.remove('hidden');
            loadAllTranscriptions();
        }
        
        function showAgentPage() {
            currentView = 'agent';
            document.getElementById('historyPage').classList.add('hidden');
        }
        
        // Transcription management
        async function loadAllTranscriptions() {
            const transcriptionFiles = [
                '20250630.txt',
                '20250703.txt'
            ];
            
            allTranscriptions.clear();
            
            for (const filename of transcriptionFiles) {
                try {
                    const response = await fetch(`transcriptions/${filename}`);
                    if (response.ok) {
                        const content = await response.text();
                        const metadata = extractTranscriptionMetadata(content, filename);
                        allTranscriptions.set(filename, {
                            metadata,
                            content,
                            parsed: null
                        });
                    }
                } catch (error) {
                    console.error(`Failed to load ${filename}:`, error);
                }
            }
            
            renderTranscriptionsList();
        }
        
        function extractTranscriptionMetadata(content, filename) {
            const lines = content.split('\n').filter(line => line.trim());
            const segments = parseTranscript(content);
            
            // Extract date from filename
            const dateMatch = filename.match(/(\d{8})/);
            const date = dateMatch ? 
                `${dateMatch[1].substring(0,4)}-${dateMatch[1].substring(4,6)}-${dateMatch[1].substring(6,8)}` : 
                'æœªçŸ¥æ—¥æœŸ';
            
            // Extract participants
            const participants = Array.from(new Set(
                segments.map(seg => seg.speaker).filter(Boolean)
            ));
            
            // Calculate duration
            let totalDuration = 0;
            if (segments.length > 0) {
                const lastSegment = segments[segments.length - 1];
                if (lastSegment.time) {
                    const timeMatch = lastSegment.time.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        totalDuration = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
                    }
                }
            }
            
            return {
                filename,
                date,
                participants,
                duration: totalDuration,
                segmentCount: segments.length,
                title: `ä¼šè®®è®°å½• - ${date}`
            };
        }
        
        function renderTranscriptionsList() {
            const container = document.getElementById('transcriptionsList');
            const transcriptions = Array.from(allTranscriptions.values()).sort((a, b) => 
                b.metadata.date.localeCompare(a.metadata.date)
            );
            
            document.getElementById('transcriptCount').textContent = `${transcriptions.length} ä¸ªè½¬å½•`;
            
            if (transcriptions.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-500">
                        <div class="text-4xl mb-4">ğŸ“­</div>
                        <p class="text-lg">æš‚æ— ä¼šè®®è®°å½•</p>
                        <p class="text-sm mt-2">ç‚¹å‡»"æ–°å¢è½¬å½•"å¼€å§‹è®°å½•æ‚¨çš„ä¼šè®®</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = transcriptions.map(trans => `
                <div class="bg-white rounded-lg border border-gray-200 p-6 hover:shadow-md transition-shadow">
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">${trans.metadata.title}</h3>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-600 mb-4">
                                <div class="flex items-center gap-1">
                                    <span>ğŸ“…</span>
                                    <span>${trans.metadata.date}</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <span>â±ï¸</span>
                                    <span>${Math.floor(trans.metadata.duration / 60)}:${(trans.metadata.duration % 60).toString().padStart(2, '0')}</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <span>ğŸ’¬</span>
                                    <span>${trans.metadata.segmentCount} ä¸ªç‰‡æ®µ</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <span>ğŸ‘¥</span>
                                    <span>${trans.metadata.participants.length} äººå‚ä¸</span>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-1 mb-3">
                                ${trans.metadata.participants.map(p => 
                                    `<span class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded">${p}</span>`
                                ).join('')}
                            </div>
                        </div>
                        <div class="flex gap-2 ml-4">
                            <button onclick="loadTranscription('${trans.metadata.filename}')" 
                                    class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-sm">
                                ğŸ¯ åˆ†ææ­¤ä¼šè®®
                            </button>
                            <button onclick="deleteTranscription('${trans.metadata.filename}')" 
                                    class="px-3 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm">
                                ğŸ—‘ï¸
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function loadTranscription(filename) {
            const transcription = allTranscriptions.get(filename);
            if (!transcription) {
                alert('è½¬å½•æ–‡ä»¶æœªæ‰¾åˆ°');
                return;
            }
            
            // Parse and load the transcription
            segments = parseTranscript(transcription.content);
            allTerms = extractTerms(segments);
            currentTranscriptionId = filename;
            
            // Reset state
            currentIndex = -1;
            selectedTerm = null;
            lastLLMCallIndex = -1;
            keywordCallInProgress = false;
            llmKeywords.clear();
            
            // Update UI
            document.getElementById('currentTranscriptInfo').textContent = transcription.metadata.title;
            document.getElementById('currentTranscriptInfo').classList.remove('hidden');
            document.getElementById('keywordCount').textContent = '0';
            
            // Re-render
            renderTranscript();
            updateTimeline();
            
            // Clear definition panel
            document.getElementById('definitionContent').innerHTML = `
                <div class="text-sm text-gray-500 text-center py-8">
                    ç‚¹å‡»å·¦ä¾§é«˜äº®æœ¯è¯­æŸ¥çœ‹å®šä¹‰
                </div>
            `;
            
            // Switch back to agent view
            showAgentPage();
            
            alert(`å·²åŠ è½½ä¼šè®®è®°å½•: ${transcription.metadata.title}`);
        }
        
        function deleteTranscription(filename) {
            if (confirm(`ç¡®å®šè¦åˆ é™¤ "${filename}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
                allTranscriptions.delete(filename);
                if (currentTranscriptionId === filename) {
                    // Clear current transcription if it was deleted
                    segments = [];
                    currentTranscriptionId = null;
                    document.getElementById('currentTranscriptInfo').classList.add('hidden');
                    renderTranscript();
                    updateTimeline();
                }
                renderTranscriptionsList();
            }
        }

        // Enhanced initialization
        function initializeWithHistory() {
            console.log('Initializing Post-Meeting Agent with History...');
            
            // Load example data as default
            segments = parseTranscript(sampleTranscript);
            allTerms = extractTerms(segments);
            renderTranscript();
            updateTimeline();
            
            // Pre-load all transcriptions for history
            loadAllTranscriptions();
            
            console.log('Ready:', segments.length, 'segments,', allTerms.size, 'terms');
        }

        // Start when page loads
        window.onload = initializeWithHistory;
    </script>
</body>
</html>
